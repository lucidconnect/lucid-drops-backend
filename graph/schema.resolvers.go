package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.38

import (
	"context"
	"errors"
	"fmt"
	"os"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/lucidconnect/inverse/drops"
	"github.com/lucidconnect/inverse/engine/aiimages"
	"github.com/lucidconnect/inverse/graph/model"
	"github.com/lucidconnect/inverse/internal"
	"github.com/lucidconnect/inverse/internal/customError"
	"github.com/lucidconnect/inverse/services"
	"github.com/lucidconnect/inverse/services/neynar"
	"github.com/lucidconnect/inverse/structure"
	"github.com/lucidconnect/inverse/utils"
	"github.com/lucidconnect/inverse/whitelist"
	"github.com/rs/zerolog/log"
)

// Items is the resolver for the items field.
func (r *dropResolver) Items(ctx context.Context, obj *model.Drop) ([]*model.Item, error) {
	var itemArr []*model.Item

	opCtx := graphql.GetFieldContext(ctx)
	for parent := opCtx.Parent; parent != nil; parent = parent.Parent {
		if parent.IsResolver {
			if parent.Field.Name == "fetchDropById" || parent.Field.Name == "fetchCreatorDrops" {
				items, err := r.NFTRepository.FetchDropItems(obj.ID, false)
				if err != nil {
					return []*model.Item{}, nil
				} else {
					mappedItems := make([]*model.Item, len(items))
					for i, item := range items {
						mappedItems[i] = item.ToGraphData()
					}
					itemArr = mappedItems
				}
				return itemArr, nil
			}
		}
	}

	// itemArr, err = drops.FetchDropItems(obj.ID, true, nil)
	// if err != nil {
	// 	return []*model.Item{}, nil
	// }
	return itemArr, nil
}

// Creator is the resolver for the creator field.
func (r *itemResolver) Creator(ctx context.Context, obj *model.Item) (*model.CreatorDetails, error) {
	drop, err := r.NFTRepository.FindDropById(obj.DropID)
	if err != nil {
		return nil, err
	}

	creator, err := r.CreatorRepository.FindCreatorById(drop.CreatorID.String())
	if err != nil {
		return nil, err
	}

	return creator.ToGraphData(), nil
}

// AuthorizedSubdomains is the resolver for the authorizedSubdomains field.
func (r *itemResolver) AuthorizedSubdomains(ctx context.Context, obj *model.Item) ([]string, error) {
	// subdomains, err := drops.FetchAuthotizedSubdomainsForItem(obj.ID)
	// if err != nil {
	// 	return []string{}, nil
	// }

	return nil, fmt.Errorf("not implemented")
}

// Holders is the resolver for the holders field.
func (r *itemResolver) Holders(ctx context.Context, obj *model.Item) ([]string, error) {
	var alchemyOpts []services.Option
	apiKeyOpt := services.WithApiKey(os.Getenv("ALCHEMY_API_KEY"))
	urlOpt := services.WithUrl(os.Getenv("ALCHEMY_URL"))
	alchemyOpts = append(alchemyOpts, apiKeyOpt, urlOpt)
	alchemyClient, err := services.NewAlchemyClient(alchemyOpts...)
	if err != nil {
		log.Err(err).Send()
		return nil, err
	}

	holders, err := alchemyClient.GetOwnersForNft(obj.DropAddress, "1")
	if err != nil {
		log.Err(err).Send()
		return nil, err
	}

	return holders, nil
}

// RegisterInverseUsername is the resolver for the registerInverseUsername field.
func (r *mutationResolver) RegisterInverseUsername(ctx context.Context, input model.NewUsernameRegisgration) (*model.CreatorDetails, error) {
	authenticationDetails, err := internal.GetAuthDetailsFromContext(ctx)
	if err != nil {
		return nil, customError.ErrToGraphQLError(structure.LucidInternalError, err.Error(), ctx)
	}

	_, err = r.CreatorRepository.FindCreatorByUsername(input.InverseUsername)
	if err == nil {
		return nil, errors.New("inverse name isn't available")
	}
	// cachedCreator, err := r.CreatorRepository.FindCreatorByEthereumAddress(authenticationDetails.Address.Hex())
	newCreator := drops.NewCreator(authenticationDetails.Address.Hex())
	newCreator.InverseUsername = utils.GetStrPtr(input.InverseUsername)
	newCreator.AAWalletAddress = input.AaWallet
	if input.ExternalWalletAddress != nil {
		newCreator.ExternalWalletAddress = *input.ExternalWalletAddress
	}

	// TODO: CreateWallet

	altSigner := &drops.SignerInfo{
		WalletAddress: input.AaWallet,
		Provider:      model.SignerProviderConnectKit,
	}
	if err = r.CreatorRepository.CreateProfile(newCreator, altSigner); err != nil {
		return nil, err
	}

	return newCreator.ToGraphData(), nil
}

// EditUserProfile is the resolver for the editUserProfile field.
func (r *mutationResolver) EditUserProfile(ctx context.Context, input model.EditUserProfileInputType) (*model.UserProfileType, error) {
	authenticationDetails, err := internal.GetAuthDetailsFromContext(ctx)
	if err != nil {
		return nil, customError.ErrToGraphQLError(structure.LucidInternalError, err.Error(), ctx)
	}

	creator, err := r.CreatorRepository.FindCreatorByEthereumAddress(authenticationDetails.Address.Hex())
	if err != nil {
		return nil, err
	}

	signer, err := r.CreatorRepository.FindSignerByCreatorId(creator.ID.String())
	if err != nil {
		return nil, err
	}

	if input.InverseUsername != nil {
		creator.InverseUsername = input.InverseUsername
	}

	if input.Bio != nil {
		creator.Bio = input.Bio
	}

	if input.Image != nil {
		creator.Image = input.Image
	}

	if input.Thumbnail != nil {
		creator.Thumbnail = input.Thumbnail
	}

	if input.Socials != nil {
		if input.Socials.Twitter != nil {
			creator.Twitter = input.Socials.Twitter
		}

		if input.Socials.Instagram != nil {
			creator.Instagram = input.Socials.Instagram
		}

		if input.Socials.Github != nil {
			creator.Github = input.Socials.Github
		}

		if input.Socials.Warpcast != nil {
			creator.Warpcast = input.Socials.Warpcast
		}
	}

	if input.AaWallet != nil {
		creator.AAWalletAddress = *input.AaWallet
		signer.WalletAddress = *input.AaWallet
	}

	err = r.CreatorRepository.UpdateCreatorProfile(creator, signer)
	if err != nil {
		return nil, err
	}

	return creator.CreatorToProfileData(), nil
}

// CreateDrop is the resolver for the createDrop field.
func (r *mutationResolver) CreateDrop(ctx context.Context, input model.DropInput) (*model.Drop, error) {
	authenticationDetails, err := internal.GetAuthDetailsFromContext(ctx)
	if err != nil {
		return nil, customError.ErrToGraphQLError(structure.LucidInternalError, err.Error(), ctx)
	}

	creator, err := r.CreatorRepository.FindCreatorByEthereumAddress(authenticationDetails.Address.Hex())
	if err != nil {
		log.Err(err).Send()
		return nil, customError.ErrToGraphQLError(structure.InvalidRequestError, err.Error(), ctx)
	}
	if input.Name == nil || input.Image == nil || input.Thumbnail == nil || input.Description == nil {
		return nil, errors.New("pass in all Fields inorder to create a new drop")
	}

	signerInfo, err := r.CreatorRepository.FindSignerByCreatorId(creator.ID.String())
	if err != nil {
		log.Err(err).Send()
		return nil, customError.ErrToGraphQLError(structure.LucidInternalError, err.Error(), ctx)
	}

	var contractAdddress string
	if input.ContractAddress == nil {
		// Introduce an artificial delay for before fethcing the actual contract address
		time.Sleep(time.Second * 3)

		contractAdddress, err = services.GetOnchainContractAddressFromDeploymentHash(input.DeploymentHash)
		if err != nil {
			log.Err(err)
		}

	} else {
		contractAdddress = *input.ContractAddress
	}

	gasIsSponsored := false
	if input.GasIsCreatorSponsored {
		gasIsSponsored = true
	}

	newDrop := &drops.Drop{
		CreatorID:              creator.ID,
		CreatorAddress:         signerInfo.WalletAddress,
		Name:                   *input.Name,
		Image:                  *input.Image,
		Thumbnail:              *input.Thumbnail,
		Description:            *input.Description,
		BlockchainNetwork:      input.Network,
		AAWalletDeploymentHash: &input.DeploymentHash,
		AAContractAddress:      &contractAdddress,
		MintPrice:              input.MintPrice,
		GasIsCreatorSponsored:  gasIsSponsored,
		UserLimit:              input.UserLimit,
		EditionLimit:           input.EditionLimit,
	}

	newItem := &drops.Item{
		Name:         *input.Name,
		Image:        *input.Image,
		Description:  *input.Description,
		TokenID:      int64(1),
		DropAddress:  contractAdddress,
		UserLimit:    input.UserLimit,
		EditionLimit: input.EditionLimit,
	}

	if err = r.NFTRepository.CreateDrop(newDrop, newItem); err != nil {
		log.Err(err).Send()
		return nil, customError.ErrToGraphQLError(structure.LucidInternalError, err.Error(), ctx)
	}

	url, err := createMintUrl(newDrop.ID.String(), newItem.Image, *newDrop.AAContractAddress)
	if err != nil {
		log.Err(err).Caller().Send()
		return newDrop.ToGraphData(nil), customError.ErrToGraphQLError(structure.LucidInternalError, "generating frame url failed", ctx)
	}
	newDrop.MintUrl = url
	if err = r.NFTRepository.UpdateDropDetails(newDrop); err != nil {
		log.Err(err).Send()
		return newDrop.ToGraphData(nil), customError.ErrToGraphQLError(structure.LucidInternalError, err.Error(), ctx)
	}

	var items []*model.Item
	item := newItem.ToGraphData()
	items = append(items, item)
	return newDrop.ToGraphData(items), nil
}

// UpdateDrop is the resolver for the updateDrop field.
func (r *mutationResolver) UpdateDrop(ctx context.Context, dropID string, input model.DropInput) (*model.Drop, error) {
	authenticationDetails, err := internal.GetAuthDetailsFromContext(ctx)
	if err != nil {
		return nil, customError.ErrToGraphQLError(structure.LucidInternalError, err.Error(), ctx)
	}

	creator, err := r.CreatorRepository.FindCreatorByEthereumAddress(authenticationDetails.Address.Hex())
	if err != nil {
		log.Err(err).Caller().Send()
		return nil, customError.ErrToGraphQLError(structure.LucidInternalError, err.Error(), ctx)
	}

	drop, err := r.NFTRepository.FindDropById(dropID)
	if err != nil {
		log.Err(err).Caller().Send()
		return nil, customError.ErrToGraphQLError(structure.LucidInternalError, "drop  not found", ctx)
	}

	if creator.ID != drop.CreatorID {
		return nil, errors.New("the drop doesn't belong to this creator")
	}

	if input.Name != nil {
		drop.Name = *input.Name
	}

	if input.Image != nil {
		drop.Image = *input.Image
	}

	if input.Thumbnail != nil {
		drop.Image = *input.Thumbnail
	}

	if input.Description != nil {
		drop.Description = *input.Description
	}

	if err = r.NFTRepository.UpdateDropDetails(drop); err != nil {
		log.Err(err).Caller().Send()
		return nil, customError.ErrToGraphQLError(structure.LucidInternalError, "drop update failed", ctx)
	}

	return drop.ToGraphData(nil), nil
}

// DeleteDrop is the resolver for the deleteDrop field.
func (r *mutationResolver) DeleteDrop(ctx context.Context, dropID string) (*model.Drop, error) {
	authenticationDetails, err := internal.GetAuthDetailsFromContext(ctx)
	if err != nil {
		return nil, customError.ErrToGraphQLError(structure.LucidInternalError, err.Error(), ctx)
	}

	creator, err := r.CreatorRepository.FindCreatorByEthereumAddress(authenticationDetails.Address.Hex())
	if err != nil {
		log.Err(err).Caller().Send()
		return nil, customError.ErrToGraphQLError(structure.LucidInternalError, err.Error(), ctx)
	}

	drop, err := r.NFTRepository.FindDropById(dropID)
	if err != nil {
		log.Err(err).Caller().Send()
		return nil, customError.ErrToGraphQLError(structure.LucidInternalError, err.Error(), ctx)
	}

	if creator.ID != drop.CreatorID {
		return nil, customError.ErrToGraphQLError(structure.InvalidRequestError, "drop doesn't belong to this creator", ctx)
	}

	if err = r.NFTRepository.DeleteDrop(drop); err != nil {
		log.Err(err).Caller().Send()
		return nil, customError.ErrToGraphQLError(structure.LucidInternalError, "delete action failed", ctx)
	}

	return drop.ToGraphData(nil), nil
}

// CreateFarcasterCriteriaForDrop is the resolver for the createFarcasterCriteriaForDrop field.
func (r *mutationResolver) CreateFarcasterCriteriaForDrop(ctx context.Context, input model.NewFarcasterCriteriaInput) (*model.Drop, error) {
	authenticationDetails, err := internal.GetAuthDetailsFromContext(ctx)
	if err != nil {
		return nil, customError.ErrToGraphQLError(structure.LucidInternalError, err.Error(), ctx)
	}

	creator, err := r.CreatorRepository.FindCreatorByEthereumAddress(authenticationDetails.Address.Hex())
	if err != nil {
		return nil, errors.New("creator has not been onboarded to create a new drop")
	}

	drop, err := r.NFTRepository.FindDropById(input.DropID)
	if err != nil {
		return nil, errors.New("drop not found")
	}

	if drop.Criteria != "" {
		//Delete Existing criteria
		err := r.NFTRepository.RemoveFarcasterCriteria(drop.ID.String())
		if err != nil {
			return nil, err
		}
	}

	var interactions string
	for _, interaction := range input.Interaction {
		interactions += fmt.Sprintf("%v,", interaction.String())
	}
	var criteriaTypes string
	for _, criteriaType := range input.CriteriaType {
		criteriaTypes += fmt.Sprintf("%v,", criteriaType.String())
	}

	criteria := &drops.FarcasterCriteria{
		DropId:       drop.ID,
		CreatorID:    creator.ID,
		CriteriaType: criteriaTypes,
		Interactions: interactions,
	}

	if input.CastURL != nil {
		criteria.CastUrl = *input.CastURL
	}
	if input.ChannelID != nil {
		var channels string
		for _, channel := range input.ChannelID {
			channels += fmt.Sprintf("%v,", channel)
		}

		criteria.ChannelID = channels
	}
	if input.FarcasterUserName != nil {
		// resolve farcaster id by username
		apiKeyOpt := neynar.WithNeynarApiKey(os.Getenv("NEYNAR_API_KEY"))
		neynarClient, err := neynar.NewNeynarClient(apiKeyOpt)
		if err != nil {
			log.Err(err).Send()
			return nil, err
		}

		fid, err := neynarClient.FetchFarcasterUserByUsername(*input.FarcasterUserName)
		if err != nil {
			return nil, err
		}
		criteria.FarcasterProfileID = fmt.Sprint(fid)
		criteria.FarcasterUsername = *input.FarcasterUserName
	}

	drop.Criteria = criteriaTypes
	if err = r.NFTRepository.AddFarcasterCriteriaToDrop(drop, criteria); err != nil {
		log.Err(err).Send()
		return nil, err
	}

	return drop.ToGraphData(nil), nil
}

// CreateMintPass is the resolver for the createMintPass field.
func (r *mutationResolver) CreateMintPass(ctx context.Context, dropID string, walletAddress string) (*model.ValidationRespoonse, error) {
	var mintPass *drops.MintPass
	resp := &model.ValidationRespoonse{
		Valid: false,
	}

	drop, err := r.NFTRepository.FindDropById(dropID)
	if err != nil {
		log.Err(err).Send()
		return nil, errors.New("drop not found")
	}

	mintPass, err = r.NFTRepository.GetMintPassForWallet(dropID, walletAddress)
	if err != nil {
		if drop.AAContractAddress == nil {
			return nil, errors.New("drop contract address not found")
		}
		if drop.EditionLimit != nil {
			count, err := r.NFTRepository.CountMintPassesForDrop(dropID)
			if err != nil {
				return nil, err
			}
			if int(count) >= *drop.EditionLimit {
				resp.Message = utils.GetStrPtr("this nft has reached it's mint")
				return resp, errors.New("item edition limit reached")
			}
		}

		if drop.UserLimit != nil {
			passes, err := r.NFTRepository.CountMintPassesForAddress(mintPass.DropID, walletAddress)
			if err == nil {
				if int(passes) >= *drop.UserLimit {
					resp.Message = utils.GetStrPtr("mint limit exhausted for wallet")
					return resp, errors.New(*resp.Message)
				}
			}
		}

		if drop.Criteria != "" {
			switch {
			case (drop.FarcasterCriteria != nil):
				apiKeyOpt := neynar.WithNeynarApiKey(os.Getenv("NEYNAR_API_KEY"))
				neynarClient, err := neynar.NewNeynarClient(apiKeyOpt)
				if err != nil {
					log.Err(err).Send()
					return resp, err
				}

				resp, err := neynarClient.ValidateFarcasterCriteriaForDrop(walletAddress, *drop)
				if err != nil {
					return resp, err
				}
			default:
				return resp, nil
			}
		}

		mintPass = &drops.MintPass{
			DropID:              dropID,
			DropContractAddress: *drop.AAContractAddress,
			BlockchainNetwork:   drop.BlockchainNetwork,
			MinterAddress:       walletAddress,
			TokenID:             "1",
		}
		if err = r.NFTRepository.CreateMintPass(mintPass); err != nil {
			return nil, err
		}

		resp.Valid = true
		resp.PassID = utils.GetStrPtr(mintPass.ID.String())
	} else {
		// get used mint passes
		mintPassCount, err := r.NFTRepository.GetMintPassesForWallet(dropID, walletAddress)
		if err != nil {
			return nil, err
		}
		if mintPassCount < int64(*drop.UserLimit) {
			mintPass.MinterAddress = walletAddress
		} else {
			resp.Message = utils.GetStrPtr("limit reached for wallet")
			return resp, nil
		}
	}

	if drop.GasIsCreatorSponsored {
		// go ahead and mint
		authResponse, err := whitelist.GenerateSignatureForClaim(*mintPass)
		if err != nil {
			log.Err(err).Send()
			return resp, err
		}

		tx, err := whitelist.MintNft(*authResponse, walletAddress)
		if err != nil {
			return resp, err
		}
		resp.TransactionHash = &tx
		return resp, nil
	}

	return resp, nil
}

// GenerateSignatureForClaim is the resolver for the generateSignatureForClaim field.
func (r *mutationResolver) GenerateSignatureForClaim(ctx context.Context, input model.GenerateClaimSignatureInput) (*model.MintAuthorizationResponse, error) {
	// authenticationDetails, err := internal.GetAuthDetailsFromContext(ctx)
	// if err != nil {
	// 	return nil, customError.ErrToGraphQLError(structure.LucidInternalError, err.Error(), ctx)
	// }
	if IsThisAValidEthAddress(input.ClaimingAddress) {
		return nil, errors.New("the address in not a valid Ethereum address")
	}

	now := time.Now()
	mintPass, err := r.NFTRepository.GetMintPassById(input.OtpRequestID)
	if err != nil {
		return nil, errors.New("mint pass not found")
	}

	if mintPass.UsedAt != nil {
		return nil, errors.New("mint pass has already been used")
	}

	passes, err := r.NFTRepository.CountMintPassesForAddress(mintPass.DropID, input.ClaimingAddress)
	if err == nil {
		if passes != 0 {
			return nil, errors.New("more than one mint pass found for this minter address")
		}
	}

	mintPass.MinterAddress = input.ClaimingAddress
	mintPass.UsedAt = &now
	err = r.NFTRepository.UpdateMintPass(mintPass)
	if err != nil {
		log.Err(err).Send()
		return nil, customError.ErrToGraphQLError(structure.LucidInternalError, err.Error(), ctx)
	}

	return whitelist.GenerateSignatureForClaim(*mintPass)
}

// GetCreatorDetails is the resolver for the getCreatorDetails field.
func (r *queryResolver) GetCreatorDetails(ctx context.Context) (*model.CreatorDetails, error) {
	// var creator drops.Creator
	authenticationDetails, err := internal.GetAuthDetailsFromContext(ctx)
	if err != nil {
		log.Err(err).Msg("auth details returned an error")
		return nil, customError.ErrToGraphQLError(structure.LucidInternalError, err.Error(), ctx)
	}

	creator, err := r.CreatorRepository.FindCreatorByEthereumAddress(authenticationDetails.Address.Hex())
	if err != nil {
		return nil, customError.ErrToGraphQLError(structure.LucidInternalError, err.Error(), ctx)
	}

	return creator.ToGraphData(), nil
}

// GetWallet is the resolver for the getWallet field.
func (r *queryResolver) GetWallet(ctx context.Context) (*model.Wallet, error) {
	// authenticationDetails, err := internal.GetAuthDetailsFromContext(ctx)
	// if err != nil {
	// 	return nil, customError.ErrToGraphQLError(structure.LucidInternalError, err.Error(), ctx)
	// }

	// creator, err := r.CreatorRepository.FindCreatorByEthereumAddress(authenticationDetails.Address.Hex())
	// if err != nil {
	// 	return nil, customError.ErrToGraphQLError(structure.LucidInternalError, err.Error(), ctx)
	// }

	return nil, fmt.Errorf("not implemented")
}

// IsInverseNameIsAvailable is the resolver for the isInverseNameIsAvailable field.
func (r *queryResolver) IsInverseNameIsAvailable(ctx context.Context, input model.NewUsernameRegisgration) (bool, error) {
	_, err := r.CreatorRepository.FindCreatorByUsername(input.InverseUsername)
	if err == nil {
		return false, nil
	}

	return true, nil
}

// FetchDropByID is the resolver for the fetchDropById field.
func (r *queryResolver) FetchDropByID(ctx context.Context, dropID string) (*model.Drop, error) {
	drop, err := r.NFTRepository.FindDropById(dropID)
	if err != nil {
		log.Err(err).Send()
		return nil, errors.New("drop not found")
	}

	items, _ := r.NFTRepository.FetchDropItems(dropID, false)
	mappedItems := make([]*model.Item, len(items))
	for idx, item := range items {
		// mintPasses, _ := FetchMintPassesForDrops(dropID)
		// item.MintPasses = mintPasses
		mappedItems[idx] = item.ToGraphData()
	}
	for _, item := range mappedItems {
		holders, err := fetchNftHolders(item)
		if err != nil {
			log.Err(err).Send()
		}
		item.Holders = holders
	}
	return drop.ToGraphData(mappedItems), nil
}

// FetchCreatorDrops is the resolver for the fetchCreatorDrops field.
func (r *queryResolver) FetchCreatorDrops(ctx context.Context) ([]*model.Drop, error) {
	authenticationDetails, err := internal.GetAuthDetailsFromContext(ctx)
	if err != nil {
		return nil, customError.ErrToGraphQLError(structure.LucidInternalError, err.Error(), ctx)
	}

	creator, err := r.CreatorRepository.FindCreatorByEthereumAddress(authenticationDetails.Address.Hex())
	if err != nil {
		return nil, err
	}

	drops, err := r.NFTRepository.FindDropByCreatorId(creator.ID.String())
	if err != nil {
		return nil, err
	}

	mappedDrops := make([]*model.Drop, len(drops))
	for i, drop := range drops {
		items, err := r.NFTRepository.FetchDropItems(drop.ID.String(), false)
		if err != nil {
			log.Err(err).Caller().Send()
			continue
		}
		mappedItems := make([]*model.Item, len(items))
		for idx, item := range items {
			mappedItems[idx] = item.ToGraphData()
		}

		mappedDrops[i] = drop.ToGraphData(mappedItems)
	}

	return mappedDrops, nil
}

// GetImageSuggestions is the resolver for the getImageSuggestions field.
func (r *queryResolver) GetImageSuggestions(ctx context.Context, prompt string, preset *model.AiImageStyle) ([]*model.ImageResponse, error) {
	// authenticationDetails, err := internal.GetAuthDetailsFromContext(ctx)
	// if err != nil {
	// 	return nil, customError.ErrToGraphQLError(structure.LucidInternalError, err.Error(), ctx)
	// }
	return aiimages.GetImageSuggestions(prompt, preset)
}

// FetchFeaturedDrops is the resolver for the fetchFeaturedDrops field.
func (r *queryResolver) FetchFeaturedDrops(ctx context.Context) ([]*model.Drop, error) {
	drops, err := r.NFTRepository.FindFeaturedDrops()
	if err != nil {
		return nil, err
	}
	mappedDrops := make([]*model.Drop, len(drops))
	for idx, drop := range drops {
		mappedDrops[idx] = drop.ToGraphData(nil)
	}

	return mappedDrops, nil
}

// GetUserProfileDetails is the resolver for the getUserProfileDetails field.
func (r *queryResolver) GetUserProfileDetails(ctx context.Context, userName string) (*model.UserProfileType, error) {
	creator, err := r.CreatorRepository.FindCreatorByUsername(userName)
	if err != nil {
		return nil, err
	}

	profileData := creator.CreatorToProfileData()

	creatorDrops, err := r.NFTRepository.FindDropByCreatorId(creator.ID.String())
	if err != nil {
		return nil, customError.ErrToGraphQLError(structure.LucidInternalError, err.Error(), ctx)
	}

	var allItems []*model.Item
	for _, drop := range creatorDrops {
		items, err := r.NFTRepository.FetchDropItems(drop.ID.String(), false)
		if err != nil {
			continue
		}
		for _, item := range items {
			allItems = append(allItems, item.ToGraphData())
		}
	}

	mappedDrops := make([]*model.Drop, len(creatorDrops))
	for idx, drop := range creatorDrops {
		mappedDrops[idx] = drop.ToGraphData(allItems)
	}
	profileData.Drops = mappedDrops

	return profileData, nil
}

// Drop returns DropResolver implementation.
func (r *Resolver) Drop() DropResolver { return &dropResolver{r} }

// Item returns ItemResolver implementation.
func (r *Resolver) Item() ItemResolver { return &itemResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type dropResolver struct{ *Resolver }
type itemResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
