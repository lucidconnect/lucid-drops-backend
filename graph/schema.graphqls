# Use @goField(forceResolver: true) to lazily handle recursive or expensive fields that shouldn't be
# resolved unless the caller asks for them
directive @goField(
    forceResolver: Boolean
    name: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

type Query {
  getCreatorDetails: CreatorDetails!
  getOnboardinProgress: OnboardingProgress!
  isInverseNameIsAvailable(input: NewUsernameRegisgration!): Boolean!

  fetchCollectionById(collectionID: String!): Collection!
  fetchCreatorCollections: [Collection!]!

  fetchItemsInCollection(collectionID: String!): [Item!]!
  fetchItemById(itemID: String!): Item!

  getImageSuggestions(prompt: String!, preset: AiImageStyle ): [ImageResponse]!
  getTweetDetails(tweetLink: String!): TweetDetails!
  getTwitterUserDetails(userName: String!): UserDetails!
}

type Mutation {
  registerInverseUsername(input: NewUsernameRegisgration!): CreatorDetails!

  createCollection(input: CollectionInput!): Collection!
  updateCollection(collectionID: String!,input: CollectionInput!): Collection!

  createItem(input: ItemInput!): Item!
  updateItem(itemID: String!,input: ItemInput!): Item!

  createEmailWhitelistForItem(input: NewEmailWhitelistInput!): Item!
  createEmailDomainWhitelist(input: NewEmailDomainWhitelistInput!): Item!
  createTwitterCriteriaForItem(input: NewTwitterCriteriaInput!): Item!
  createTelegramCriteriaForItem(input: NewTelegramCriteriaInput!): Item!
  createPatreonCriteriaForItem(input: NewPatreonCriteriaInput!): Item!
  validateTwitterCriteriaForItem(itemID: String!, authID: String): Boolean!
  validateTelegramCriteriaForItem(itemID: String!, authID: String): Boolean!
  validatePatreonCriteriaForItem(itemID: String!, authID: String): Boolean!

  startEmailVerificationForClaim(input: EmailClaimInput!): StartEmailVerificationResponse!
  completeEmailVerificationForClaim(input: CompleteEmailVerificationInput!): CompleteEmailVerificationResponse!
  generateSignatureForClaim(input: GenerateClaimSignatureInput!): MintAuthorizationResponse!

  storeSignerInfo(input: SignerInfo!): Boolean!
}

""" Time formated in the time.RFC3339Nano Format """
scalar Time

input NewEmailWhitelistInput {
  itemID: String!
  authorizedEmails: [String!]!
}

input EmailClaimInput {
  itemID: String!
  emailAddress: String!
}

input CompleteEmailVerificationInput {
  otp: String!
  otpRequestID: String!
}

input CompleteEmailClaimInput {
  otp: String!
  otpRequestID: String!
}

input GenerateClaimSignatureInput {
  otpRequestID: String!
  claimingAddress: String!
}

input NewEmailDomainWhitelistInput {
  itemID: String!
  visible: Boolean!
  authorizedSubdomains: [String!]!
}

input NewUsernameRegisgration {
  inverseUsername: String!
}

input CollectionInput {
	name: String
	description: String
	image: String
	thumbnail: String
}

input ItemInput {
	name: String
	image: String
	description: String
	collectionID: String
}

input NewTwitterCriteriaInput {
	itemID: String!
	profileID: String
	tweetLink: String
	interaction: [InteractionType]
  criteriaType: ClaimCriteriaType!
  twitterAuthID: String!
  """
  Format: 2006-01-02T15:04:05Z07:00 i.e YYYY-MM-DDTHH:MM:SSZ
  """
	cutOffDate: String
}

input NewTelegramCriteriaInput {
	itemID: String!
  groupID: String!
}

input NewPatreonCriteriaInput {
  itemID: String!
  authID: String!
  campaignID: String
}

input SignerInfo {
  address: String!
  signature: String
  provider: SignerProvider!
}

type Collection {
  ID: ID!
	name: String!
	description: String!
	image: String!
	thumbnail: String!
  contractAddress: String
  items: [Item!]! @goField(forceResolver: true)
}

type OnboardingProgress{
  registerdInverseUsername: Boolean!
}

type CreatorDetails {
  creatorID: ID!
  address: String!
  inverseUsername: String
}

type Item {
  ID: ID!
	name: String!
	image: String!
	description: String!
	collectionId: String!
  claimCriteria: ClaimCriteriaType
  creator: CreatorDetails! @goField(forceResolver: true)
  authorizedSubdomains: [String!] @goField(forceResolver: true)
  twitterClaimCriteriaInteractions: [InteractionType]
  tweetLink: String
  profileLink: String
  createdAt: Time!
}

type ImageResponse {
  image: String!
  format: ImageResolveFormaat!
}

type StartEmailVerificationResponse {
  otpRequestID: String!
}

type CompleteEmailVerificationResponse {
  otpRequestID: String!
}

type MintAuthorizationResponse {
  packedData: String!
  mintingABI: String!
  mintingSignature: String!
  smartContractAddress: String!
}

type TweetDetails {
  profilePhoto: String!
  profileName: String!
  profileHandle: String!
  tweetText: String!
}

type UserDetails {
  id: String!
  name: String!
  username: String!

}

enum ClaimCriteriaType{
  emailWhiteList
  emailDomain
  twitterInteractions
  twitterFollowers
  telegram
}

enum AiImageStyle{
  Anime
  Artistic
  Futuristic
  Cinematic
  DigitalArt
  FantasyArt
  LineArt
  NeonPunk
  Origami
  PixelArt
  ThreeDimensional
}

enum ImageResolveFormaat {
  Url
  Base64
}

enum InteractionType {
  likes
  retweets
  replies
}

enum SignerProvider {
  dynamic
  magic
}



