# Use @goField(forceResolver: true) to lazily handle recursive or expensive fields that shouldn't be
# resolved unless the caller asks for them
directive @goField(
    forceResolver: Boolean
    name: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

type Query {
  getCreatorDetails: CreatorDetails!
  getWallet: Wallet!
  getOnboardinProgress: OnboardingProgress!
  isInverseNameIsAvailable(input: NewUsernameRegisgration!): Boolean!
  getUserProfileDetails (userName: String!): userProfileType

  fetchClaimedItems(address: String!): [Item!]!

  fetchDropById(dropID: String!): Drop!
  fetchCreatorDrops: [Drop!]!

  fetchItemsInDrop(dropID: String!): [Item!]!
  fetchItemById(itemID: String!): Item!
  fetchCriteriaAuthorizedEmails(itemID: String!): [String!]
  fetchCriteriaAuthorizedWalletAddresses(itemID: String!): [String!]

  getImageSuggestions(prompt: String!, preset: AiImageStyle ): [ImageResponse]!
  getTweetDetails(tweetLink: String!): TweetDetails!
  getTwitterUserDetails(userName: String!): UserDetails!

  fetchQuestionsByItemId(itemId: String!): [QuestionnaireType!]!
  fetchFeaturedItems: [Item!]!
  fetchFeaturedDrops: [Drop!]!

  queryImageStatus(taskID: String!, position: Int): ImageStatusResponse!
}

type Mutation {
  registerInverseUsername(input: NewUsernameRegisgration!): CreatorDetails!
  editUserProfile (input: EditUserProfileInputType!):userProfileType

  createDrop(input: DropInput!): Drop!
  updateDrop(dropID: String!,input: DropInput!): Drop!
  deleteDrop(dropID: String!): Drop!

  # createItem(input: ItemInput!): Item!
  # tempCreateItem(input: ItemInput!, creatorAddress: String!): Item!
  # updateItem(itemID: String!,input: ItemInput!): Item!
  # deleteItem(itemID: String!): Item!
  # addItemDeadline(itemID: String!, deadline: String!): Item!

  # createWalletAddressWhitelistForItem(input: NewWalletAddressWhitelistInput!): Item!
  # createTwitterCriteriaForItem(input: NewTwitterCriteriaInput!): Item!
  # createTelegramCriteriaForItem(input: NewTelegramCriteriaInput!): Item!
  createEmptyCriteriaForItem(input: NewEmptyCriteriaInput!): Item!
  createFarcasterCriteriaForDrop(input: NewFarcasterCriteriaInput!): Drop!
  createMintPassForNoCriteriaItem(itemID: String!, walletAddress: String!): ValidationRespoonse
  # validateTwitterCriteriaForItem(itemID: String!, authID: String): ValidationRespoonse
  # validateTelegramCriteriaForItem(itemID: String!, authID: String): ValidationRespoonse
  # validateWalletCriteriaForItem(itemID: String!, walletAddress: String!): ValidationRespoonse
  validateFarcasterCriteriaForDrop(dropID: String!, farcasterAddress: String!): ValidationRespoonse
  createJWTToken(input: CreateJWTTokenInput): JWTCreationResponse!
  createPaymentIntentSecretKey(amount: Int!): String

  # startEmailVerificationForClaim(input: EmailClaimInput!): StartEmailVerificationResponse!
  # completeEmailVerificationForClaim(input: CompleteEmailVerificationInput!): CompleteEmailVerificationResponse!
  generateSignatureForClaim(input: GenerateClaimSignatureInput!): MintAuthorizationResponse!

  storeSignerInfo(input: SignerInfo!): Boolean!
  generateMobileWalletConfigs: MobileWalletConfig!
  storeHashForDeployment(input: DeploymentInfo!): Boolean
}
""" Time formated in the time.RFC3339Nano Format """
scalar Time

input CreateJWTTokenInput{
  address:   String!
  aaWallet:  String!
  signature: String!
}

input NewEmailWhitelistInput {
  itemID: String!
  authorizedEmails: [String!]!
}

input NewWalletAddressWhitelistInput {
  itemID: String!
  authorizedWalletAddresses: [String!]!
}

input QuestionnaireCriteriaInput {
  itemID: String!
  questionType: QuestionType!
  openEndedInput: [OpenEndedInputType!]
  multiChoiceInput: [MultiChoiceInputType!]
  claimCode: Boolean
}

input MultiChoiceInputType {
  question: String!
  choices: [String!]!
  correctChoice: String!
}

input OpenEndedInputType {
  question: String!
  answers: [String!]!
}

input QuestionnaireAnswerInput{
  answer: String!
  questionId: String!
}

input EmailClaimInput {
  itemID: String!
  emailAddress: String!
}

input CompleteEmailVerificationInput {
  otp: String!
  otpRequestID: String!
}

input CompleteEmailClaimInput {
  otp: String!
  otpRequestID: String!
}

input GenerateClaimSignatureInput {
  otpRequestID: String!
  claimingAddress: String!
}

input NewEmailDomainWhitelistInput {
  itemID: String!
  visible: Boolean!
  authorizedSubdomains: [String!]!
}

input NewUsernameRegisgration {
  aaWallet: String!
  inverseUsername: String!
}

input DropInput {
	name: String
	description: String
	image: String
	thumbnail: String
  network: BlockchainNetwork
  deploymentHash: String!
  contractAddress: String
  editionLimit: Int
  claimFee: Int
}

input ItemInput {
	name: String
	image: String
	description: String
	dropID: String
  userLimit: Int
  editionLimit: Int
  """
  This should typically be in cents
  """
  claimFee: Int
}

input NewFarcasterCriteriaInput {
  dropID: String!
  cast: String
  interaction: [InteractionType]
  criteriaType: ClaimCriteriaType!
}

input NewTwitterCriteriaInput {
	itemID: String!
	profileID: String
	tweetLink: String
	interaction: [InteractionType]
  criteriaType: ClaimCriteriaType!
  twitterAuthID: String!
  """
  Format: 2006-01-02T15:04:05Z07:00 i.e YYYY-MM-DDTHH:MM:SSZ
  """
	cutOffDate: String
}

input NewTelegramCriteriaInput {
	itemID: String!
  groupID: String!
}

input NewEmptyCriteriaInput {
	itemID: String!

}

input NewPatreonCriteriaInput {
  itemID: String!
  authID: String!
  campaignID: String
  campaignName: String
}

input SignerInfo {
  address: String!
  signature: String
  provider: SignerProvider!
}

input DeploymentInfo{
  dropId: String!
  deploymentHash: String!
  contractAddress: String
}

input EditUserProfileInputType{
	thumbnail: String
	image: String
	inverseUsername: String
	bio: String
	socials: SocialsInput
}

input SocialsInput {
  twitter: String
  instagram: String
  github: String
  warpcast: String
}

type Wallet {
  balance: Int!
  currency: String!
}

type Socials {
  twitter: String
  instagram: String
  github: String
  warpcast: String
}

type userProfileType{
	creatorID: String
	thumbnail: String
	image: String
	inverseUsername: String
	bio: String
	socials: Socials
	drops: [Drop]
	items: [Item]
	claimedItems: [Item]
}


type JWTCreationResponse{
  token: String!
}

type Drop {
  ID: ID!
  creatorID: String!
  createdAt: Time!
	name: String!
	description: String!  
	image: String!
	thumbnail: String!
  contractAddress: String
  network: BlockchainNetwork
  items: [Item!]! @goField(forceResolver: true)
  mintUrl: String!
  farcasterClaimCriteriaInteractions: [InteractionType]
  claimCriteria: ClaimCriteriaType
  castUrl: String
  farcasterProfileID: String
}

type OnboardingProgress{
  creator: CreatorDetails
  registerdInverseUsername: Boolean!
}

type CreatorDetails {
  creatorID: ID!
  address: String!
  inverseUsername: String
  firstPayment: Boolean!
}

type Item {
  ID: ID!
	name: String!
	image: String!
	description: String!
	dropId: String!
  dropAddress: String!
  claimFee: Int!
  creator: CreatorDetails! @goField(forceResolver: true)
  authorizedSubdomains: [String!] @goField(forceResolver: true)
  twitterClaimCriteriaInteractions: [InteractionType]
  telegramGroupTitle: String
  tweetLink: String
  profileLink: String
  campaignName: String
  editionLimit: Int
  TokenID: Int
  createdAt: Time!
  deadline: Time
  claimDetails: [ClaimDetails]
  holders: [String!]! @goField(forceResolver: true)
}

type QuestionnaireType {
  """ Choices will only contain a list of potential answers when the `questionType` is `multiChoice` """
  choices: [String!]
  question: String!
  questionId: String!
  questionType: QuestionType!
  claimCode: Boolean
}

type ImageResponse {
  image: String!
  format: ImageResolveFormaat!
  taskID: String
}

type StartEmailVerificationResponse {
  otpRequestID: String!
}

type CompleteEmailVerificationResponse {
  otpRequestID: String!
}

type MintAuthorizationResponse {
  amount: String!
  tokenId: String!
  nonce: String!
  chain: Int!
  packedData: String!
  mintingABI: String!
  mintingSignature: String!
  smartContractAddress: String!
}

type TweetDetails {
  profilePhoto: String!
  profileName: String!
  profileHandle: String!
  tweetText: String!
}

type UserDetails {
  id: String!
  name: String!
  username: String!

}

type MobileWalletConfig {
  publicKey: String!
  privateKey: String!
  aaWallet: String!
}

type ImageStatusResponse {
  status: String
  image: String
  percentage: Int
}

type ValidationRespoonse {
  valid: Boolean!
  passID: String
}

type ClaimDetails {
	claimTime: Time
	claimerUsername: String
	claimerAddress: String
}

enum QuestionType{
  multiChoice
  directAnswer
}

enum ClaimCriteriaType{
  emailWhiteList
  emailDomain
  twitterInteractions
  twitterFollowers
  telegram
  patreon
  directAnswerQuestionnaire
  mutliChoiceQuestionnaire
  emptyCriteria
  walletAddress
  claimCode
  farcasterChannel
  farcasterFollowing
  farcasterInteractions
}

enum AiImageStyle{
  Anime
  Artistic
  Futuristic
  Cinematic
  DigitalArt
  FantasyArt
  LineArt
  NeonPunk
  Origami
  PixelArt
  ThreeDimensional
}

enum ImageResolveFormaat {
  Url
  Base64
}

enum InteractionType {
  likes
  retweets
  replies
  recasts
}

# enum FarcasterInteractionType {
#   likes
#   replies
#   recasts
# }

enum SignerProvider {
  dynamic
  magic
  web3Auth
  connectKit
}

enum BlockchainNetwork {
  base
  polygon
}
