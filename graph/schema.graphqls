# Use @goField(forceResolver: true) to lazily handle recursive or expensive fields that shouldn't be
# resolved unless the caller asks for them
directive @goField(
    forceResolver: Boolean
    name: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

type Query {
  getCreatorDetails: CreatorDetails!
  getOnboardinProgress: OnboardingProgress!
  isInverseNameIsAvailable(input: NewUsernameRegisgration!): Boolean!

  fetchCollectionById(collectionID: String!): Collection!
  fetchCreatorCollections: [Collection!]!

  fetchItemsInCollection(collectionID: String!): [Item!]!
  fetchItemById(itemID: String!): Item!

  getImageSuggestions(prompt: String!, preset: AiImageStyle ): [String!]!
}

type Mutation {
  registerInverseUsername(input: NewUsernameRegisgration!): CreatorDetails!

  createCollection(input: CollectionInput!): Collection!
  updateCollection(collectionID: String!,input: CollectionInput!): Collection!

  createItem(input: ItemInput!): Item!
  updateItem(itemID: String!,input: ItemInput!): Item!
}

""" Time formated in the time.RFC3339Nano Format """
scalar Time

input NewUsernameRegisgration {
  inverseUsername: String!
}

input CollectionInput {
	name: String
	description: String
	image: String
	thumbnail: String
}

input ItemInput {
	name: String
	image: String
	description: String
	collectionID: String
}

type Collection {
  ID: ID!
	name: String!
	description: String!
	image: String!
	thumbnail: String!
  items: [Item!]! @goField(forceResolver: true)
}

type OnboardingProgress{
  registerdInverseUsername: Boolean!
}

type CreatorDetails {
  creatorID: ID!
  address: String!
  inverseUsername: String
}

type Item {
  ID: ID!
	name: String!
	image: String!
	description: String!
	collectionId: String!
}

enum AiImageStyle{
  Anime
  Artistic
  Futuristic
}
