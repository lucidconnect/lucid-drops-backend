// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type ClaimDetails struct {
	ClaimTime       *time.Time `json:"claimTime,omitempty"`
	ClaimerUsername *string    `json:"claimerUsername,omitempty"`
	ClaimerAddress  *string    `json:"claimerAddress,omitempty"`
}

type Collection struct {
	ID              string  `json:"ID"`
	Name            string  `json:"name"`
	Description     string  `json:"description"`
	Image           string  `json:"image"`
	Thumbnail       string  `json:"thumbnail"`
	ContractAddress *string `json:"contractAddress,omitempty"`
	Items           []*Item `json:"items"`
}

type CollectionInput struct {
	Name        *string `json:"name,omitempty"`
	Description *string `json:"description,omitempty"`
	Image       *string `json:"image,omitempty"`
	Thumbnail   *string `json:"thumbnail,omitempty"`
}

type CompleteEmailClaimInput struct {
	Otp          string `json:"otp"`
	OtpRequestID string `json:"otpRequestID"`
}

type CompleteEmailVerificationInput struct {
	Otp          string `json:"otp"`
	OtpRequestID string `json:"otpRequestID"`
}

type CompleteEmailVerificationResponse struct {
	OtpRequestID string `json:"otpRequestID"`
}

type CreateJWTTokenInput struct {
	Address   string `json:"address"`
	AaWallet  string `json:"aaWallet"`
	Signature string `json:"signature"`
}

type CreatorDetails struct {
	CreatorID       string  `json:"creatorID"`
	Address         string  `json:"address"`
	InverseUsername *string `json:"inverseUsername,omitempty"`
}

type DeploymentInfo struct {
	CollectionID    string  `json:"collectionId"`
	DeploymentHash  string  `json:"deploymentHash"`
	ContractAddress *string `json:"contractAddress,omitempty"`
}

type EmailClaimInput struct {
	ItemID       string `json:"itemID"`
	EmailAddress string `json:"emailAddress"`
}

type GenerateClaimSignatureInput struct {
	OtpRequestID    string `json:"otpRequestID"`
	ClaimingAddress string `json:"claimingAddress"`
}

type ImageResponse struct {
	Image  string              `json:"image"`
	Format ImageResolveFormaat `json:"format"`
	TaskID *string             `json:"taskID,omitempty"`
}

type ImageStatusResponse struct {
	Status     *string `json:"status,omitempty"`
	Image      *string `json:"image,omitempty"`
	Percentage *int    `json:"percentage,omitempty"`
}

type Item struct {
	ID                               string             `json:"ID"`
	Name                             string             `json:"name"`
	Image                            string             `json:"image"`
	Description                      string             `json:"description"`
	CollectionID                     string             `json:"collectionId"`
	ClaimCriteria                    *ClaimCriteriaType `json:"claimCriteria,omitempty"`
	Creator                          *CreatorDetails    `json:"creator"`
	AuthorizedSubdomains             []string           `json:"authorizedSubdomains,omitempty"`
	TwitterClaimCriteriaInteractions []*InteractionType `json:"twitterClaimCriteriaInteractions,omitempty"`
	TelegramGroupTitle               *string            `json:"telegramGroupTitle,omitempty"`
	TweetLink                        *string            `json:"tweetLink,omitempty"`
	ProfileLink                      *string            `json:"profileLink,omitempty"`
	CampaignName                     *string            `json:"campaignName,omitempty"`
	CreatedAt                        time.Time          `json:"createdAt"`
	ClaimDetails                     []*ClaimDetails    `json:"claimDetails,omitempty"`
}

type ItemInput struct {
	Name         *string `json:"name,omitempty"`
	Image        *string `json:"image,omitempty"`
	Description  *string `json:"description,omitempty"`
	CollectionID *string `json:"collectionID,omitempty"`
}

type JWTCreationResponse struct {
	Token string `json:"token"`
}

type MintAuthorizationResponse struct {
	PackedData           string `json:"packedData"`
	MintingAbi           string `json:"mintingABI"`
	MintingSignature     string `json:"mintingSignature"`
	SmartContractAddress string `json:"smartContractAddress"`
}

type MobileWalletConfig struct {
	PublicKey  string `json:"publicKey"`
	PrivateKey string `json:"privateKey"`
	AaWallet   string `json:"aaWallet"`
}

type MultiChoiceInputType struct {
	Question      string   `json:"question"`
	Choices       []string `json:"choices"`
	CorrectChoice string   `json:"correctChoice"`
}

type NewEmailDomainWhitelistInput struct {
	ItemID               string   `json:"itemID"`
	Visible              bool     `json:"visible"`
	AuthorizedSubdomains []string `json:"authorizedSubdomains"`
}

type NewEmailWhitelistInput struct {
	ItemID           string   `json:"itemID"`
	AuthorizedEmails []string `json:"authorizedEmails"`
}

type NewPatreonCriteriaInput struct {
	ItemID       string  `json:"itemID"`
	AuthID       string  `json:"authID"`
	CampaignID   *string `json:"campaignID,omitempty"`
	CampaignName *string `json:"campaignName,omitempty"`
}

type NewTelegramCriteriaInput struct {
	ItemID  string `json:"itemID"`
	GroupID string `json:"groupID"`
}

type NewTwitterCriteriaInput struct {
	ItemID        string             `json:"itemID"`
	ProfileID     *string            `json:"profileID,omitempty"`
	TweetLink     *string            `json:"tweetLink,omitempty"`
	Interaction   []*InteractionType `json:"interaction,omitempty"`
	CriteriaType  ClaimCriteriaType  `json:"criteriaType"`
	TwitterAuthID string             `json:"twitterAuthID"`
	// Format: 2006-01-02T15:04:05Z07:00 i.e YYYY-MM-DDTHH:MM:SSZ
	CutOffDate *string `json:"cutOffDate,omitempty"`
}

type NewUsernameRegisgration struct {
	AaWallet        string `json:"aaWallet"`
	InverseUsername string `json:"inverseUsername"`
}

type OnboardingProgress struct {
	Creator                  *CreatorDetails `json:"creator,omitempty"`
	RegisterdInverseUsername bool            `json:"registerdInverseUsername"`
}

type OpenEndedInputType struct {
	Question string   `json:"question"`
	Answers  []string `json:"answers"`
}

type QuestionnaireAnswerInput struct {
	Answer     string `json:"answer"`
	QuestionID string `json:"questionId"`
}

type QuestionnaireCriteriaInput struct {
	ItemID           string                  `json:"itemID"`
	QuestionType     QuestionType            `json:"questionType"`
	OpenEndedInput   []*OpenEndedInputType   `json:"openEndedInput,omitempty"`
	MultiChoiceInput []*MultiChoiceInputType `json:"multiChoiceInput,omitempty"`
}

type QuestionnaireType struct {
	//  Choices will only contain a list of potential answers when the `questionType` is `multiChoice`
	Choices      []string     `json:"choices,omitempty"`
	Question     string       `json:"question"`
	QuestionID   string       `json:"questionId"`
	QuestionType QuestionType `json:"questionType"`
}

type SignerInfo struct {
	Address   string         `json:"address"`
	Signature *string        `json:"signature,omitempty"`
	Provider  SignerProvider `json:"provider"`
}

type StartEmailVerificationResponse struct {
	OtpRequestID string `json:"otpRequestID"`
}

type TweetDetails struct {
	ProfilePhoto  string `json:"profilePhoto"`
	ProfileName   string `json:"profileName"`
	ProfileHandle string `json:"profileHandle"`
	TweetText     string `json:"tweetText"`
}

type UserDetails struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	Username string `json:"username"`
}

type ValidationRespoonse struct {
	Valid  bool    `json:"valid"`
	PassID *string `json:"passID,omitempty"`
}

type AiImageStyle string

const (
	AiImageStyleAnime            AiImageStyle = "Anime"
	AiImageStyleArtistic         AiImageStyle = "Artistic"
	AiImageStyleFuturistic       AiImageStyle = "Futuristic"
	AiImageStyleCinematic        AiImageStyle = "Cinematic"
	AiImageStyleDigitalArt       AiImageStyle = "DigitalArt"
	AiImageStyleFantasyArt       AiImageStyle = "FantasyArt"
	AiImageStyleLineArt          AiImageStyle = "LineArt"
	AiImageStyleNeonPunk         AiImageStyle = "NeonPunk"
	AiImageStyleOrigami          AiImageStyle = "Origami"
	AiImageStylePixelArt         AiImageStyle = "PixelArt"
	AiImageStyleThreeDimensional AiImageStyle = "ThreeDimensional"
)

var AllAiImageStyle = []AiImageStyle{
	AiImageStyleAnime,
	AiImageStyleArtistic,
	AiImageStyleFuturistic,
	AiImageStyleCinematic,
	AiImageStyleDigitalArt,
	AiImageStyleFantasyArt,
	AiImageStyleLineArt,
	AiImageStyleNeonPunk,
	AiImageStyleOrigami,
	AiImageStylePixelArt,
	AiImageStyleThreeDimensional,
}

func (e AiImageStyle) IsValid() bool {
	switch e {
	case AiImageStyleAnime, AiImageStyleArtistic, AiImageStyleFuturistic, AiImageStyleCinematic, AiImageStyleDigitalArt, AiImageStyleFantasyArt, AiImageStyleLineArt, AiImageStyleNeonPunk, AiImageStyleOrigami, AiImageStylePixelArt, AiImageStyleThreeDimensional:
		return true
	}
	return false
}

func (e AiImageStyle) String() string {
	return string(e)
}

func (e *AiImageStyle) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AiImageStyle(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AiImageStyle", str)
	}
	return nil
}

func (e AiImageStyle) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ClaimCriteriaType string

const (
	ClaimCriteriaTypeEmailWhiteList            ClaimCriteriaType = "emailWhiteList"
	ClaimCriteriaTypeEmailDomain               ClaimCriteriaType = "emailDomain"
	ClaimCriteriaTypeTwitterInteractions       ClaimCriteriaType = "twitterInteractions"
	ClaimCriteriaTypeTwitterFollowers          ClaimCriteriaType = "twitterFollowers"
	ClaimCriteriaTypeTelegram                  ClaimCriteriaType = "telegram"
	ClaimCriteriaTypePatreon                   ClaimCriteriaType = "patreon"
	ClaimCriteriaTypeDirectAnswerQuestionnaire ClaimCriteriaType = "directAnswerQuestionnaire"
	ClaimCriteriaTypeMutliChoiceQuestionnaire  ClaimCriteriaType = "mutliChoiceQuestionnaire"
)

var AllClaimCriteriaType = []ClaimCriteriaType{
	ClaimCriteriaTypeEmailWhiteList,
	ClaimCriteriaTypeEmailDomain,
	ClaimCriteriaTypeTwitterInteractions,
	ClaimCriteriaTypeTwitterFollowers,
	ClaimCriteriaTypeTelegram,
	ClaimCriteriaTypePatreon,
	ClaimCriteriaTypeDirectAnswerQuestionnaire,
	ClaimCriteriaTypeMutliChoiceQuestionnaire,
}

func (e ClaimCriteriaType) IsValid() bool {
	switch e {
	case ClaimCriteriaTypeEmailWhiteList, ClaimCriteriaTypeEmailDomain, ClaimCriteriaTypeTwitterInteractions, ClaimCriteriaTypeTwitterFollowers, ClaimCriteriaTypeTelegram, ClaimCriteriaTypePatreon, ClaimCriteriaTypeDirectAnswerQuestionnaire, ClaimCriteriaTypeMutliChoiceQuestionnaire:
		return true
	}
	return false
}

func (e ClaimCriteriaType) String() string {
	return string(e)
}

func (e *ClaimCriteriaType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ClaimCriteriaType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ClaimCriteriaType", str)
	}
	return nil
}

func (e ClaimCriteriaType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ImageResolveFormaat string

const (
	ImageResolveFormaatURL    ImageResolveFormaat = "Url"
	ImageResolveFormaatBase64 ImageResolveFormaat = "Base64"
)

var AllImageResolveFormaat = []ImageResolveFormaat{
	ImageResolveFormaatURL,
	ImageResolveFormaatBase64,
}

func (e ImageResolveFormaat) IsValid() bool {
	switch e {
	case ImageResolveFormaatURL, ImageResolveFormaatBase64:
		return true
	}
	return false
}

func (e ImageResolveFormaat) String() string {
	return string(e)
}

func (e *ImageResolveFormaat) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageResolveFormaat(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageResolveFormaat", str)
	}
	return nil
}

func (e ImageResolveFormaat) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InteractionType string

const (
	InteractionTypeLikes    InteractionType = "likes"
	InteractionTypeRetweets InteractionType = "retweets"
	InteractionTypeReplies  InteractionType = "replies"
)

var AllInteractionType = []InteractionType{
	InteractionTypeLikes,
	InteractionTypeRetweets,
	InteractionTypeReplies,
}

func (e InteractionType) IsValid() bool {
	switch e {
	case InteractionTypeLikes, InteractionTypeRetweets, InteractionTypeReplies:
		return true
	}
	return false
}

func (e InteractionType) String() string {
	return string(e)
}

func (e *InteractionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InteractionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InteractionType", str)
	}
	return nil
}

func (e InteractionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type QuestionType string

const (
	QuestionTypeMultiChoice  QuestionType = "multiChoice"
	QuestionTypeDirectAnswer QuestionType = "directAnswer"
)

var AllQuestionType = []QuestionType{
	QuestionTypeMultiChoice,
	QuestionTypeDirectAnswer,
}

func (e QuestionType) IsValid() bool {
	switch e {
	case QuestionTypeMultiChoice, QuestionTypeDirectAnswer:
		return true
	}
	return false
}

func (e QuestionType) String() string {
	return string(e)
}

func (e *QuestionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = QuestionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid QuestionType", str)
	}
	return nil
}

func (e QuestionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SignerProvider string

const (
	SignerProviderDynamic    SignerProvider = "dynamic"
	SignerProviderMagic      SignerProvider = "magic"
	SignerProviderWeb3Auth   SignerProvider = "web3Auth"
	SignerProviderConnectKit SignerProvider = "connectKit"
)

var AllSignerProvider = []SignerProvider{
	SignerProviderDynamic,
	SignerProviderMagic,
	SignerProviderWeb3Auth,
	SignerProviderConnectKit,
}

func (e SignerProvider) IsValid() bool {
	switch e {
	case SignerProviderDynamic, SignerProviderMagic, SignerProviderWeb3Auth, SignerProviderConnectKit:
		return true
	}
	return false
}

func (e SignerProvider) String() string {
	return string(e)
}

func (e *SignerProvider) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SignerProvider(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SignerProvider", str)
	}
	return nil
}

func (e SignerProvider) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
