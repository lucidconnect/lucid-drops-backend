// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type ClaimDetails struct {
	ClaimTime       *time.Time `json:"claimTime,omitempty"`
	ClaimerUsername *string    `json:"claimerUsername,omitempty"`
	ClaimerAddress  *string    `json:"claimerAddress,omitempty"`
}

type CompleteEmailClaimInput struct {
	Otp          string `json:"otp"`
	OtpRequestID string `json:"otpRequestID"`
}

type CompleteEmailVerificationInput struct {
	Otp          string `json:"otp"`
	OtpRequestID string `json:"otpRequestID"`
}

type CompleteEmailVerificationResponse struct {
	OtpRequestID string `json:"otpRequestID"`
}

type CreateJWTTokenInput struct {
	Address   string `json:"address"`
	AaWallet  string `json:"aaWallet"`
	Signature string `json:"signature"`
}

type CreatorDetails struct {
	CreatorID       string  `json:"creatorID"`
	Address         string  `json:"address"`
	InverseUsername *string `json:"inverseUsername,omitempty"`
	FirstPayment    bool    `json:"firstPayment"`
}

type DeploymentInfo struct {
	DropID          string  `json:"dropId"`
	DeploymentHash  string  `json:"deploymentHash"`
	ContractAddress *string `json:"contractAddress,omitempty"`
}

type Drop struct {
	ID                                 string             `json:"ID"`
	CreatorID                          string             `json:"creatorID"`
	CreatedAt                          time.Time          `json:"createdAt"`
	Name                               string             `json:"name"`
	Description                        string             `json:"description"`
	Image                              string             `json:"image"`
	Thumbnail                          string             `json:"thumbnail"`
	ContractAddress                    *string            `json:"contractAddress,omitempty"`
	Network                            *BlockchainNetwork `json:"network,omitempty"`
	Items                              []*Item            `json:"items"`
	MintURL                            string             `json:"mintUrl"`
	MintPrice                          *float64           `json:"mintPrice,omitempty"`
	GasIsCreatorSponsored              bool               `json:"gasIsCreatorSponsored"`
	FarcasterClaimCriteriaInteractions []*InteractionType `json:"farcasterClaimCriteriaInteractions,omitempty"`
	ClaimCriteria                      *ClaimCriteriaType `json:"claimCriteria,omitempty"`
	CastURL                            *string            `json:"castUrl,omitempty"`
	FarcasterProfileID                 *string            `json:"farcasterProfileID,omitempty"`
	FarcasterChannelID                 *string            `json:"farcasterChannelId,omitempty"`
	ClaimDetails                       []*ClaimDetails    `json:"claimDetails,omitempty"`
}

type DropInput struct {
	Name                  *string            `json:"name,omitempty"`
	Description           *string            `json:"description,omitempty"`
	Image                 *string            `json:"image,omitempty"`
	Thumbnail             *string            `json:"thumbnail,omitempty"`
	Network               *BlockchainNetwork `json:"network,omitempty"`
	DeploymentHash        string             `json:"deploymentHash"`
	ContractAddress       *string            `json:"contractAddress,omitempty"`
	EditionLimit          *int               `json:"editionLimit,omitempty"`
	UserLimit             *int               `json:"userLimit,omitempty"`
	ClaimFee              *int               `json:"claimFee,omitempty"`
	MintPrice             *float64           `json:"mintPrice,omitempty"`
	GasIsCreatorSponsored bool               `json:"gasIsCreatorSponsored"`
}

type EditUserProfileInputType struct {
	Thumbnail       *string       `json:"thumbnail,omitempty"`
	Image           *string       `json:"image,omitempty"`
	InverseUsername *string       `json:"inverseUsername,omitempty"`
	Bio             *string       `json:"bio,omitempty"`
	Socials         *SocialsInput `json:"socials,omitempty"`
}

type EmailClaimInput struct {
	ItemID       string `json:"itemID"`
	EmailAddress string `json:"emailAddress"`
}

type GenerateClaimSignatureInput struct {
	OtpRequestID    string `json:"otpRequestID"`
	ClaimingAddress string `json:"claimingAddress"`
}

type ImageResponse struct {
	Image  string              `json:"image"`
	Format ImageResolveFormaat `json:"format"`
	TaskID *string             `json:"taskID,omitempty"`
}

type ImageStatusResponse struct {
	Status     *string `json:"status,omitempty"`
	Image      *string `json:"image,omitempty"`
	Percentage *int    `json:"percentage,omitempty"`
}

type Item struct {
	ID                               string             `json:"ID"`
	Name                             string             `json:"name"`
	Image                            string             `json:"image"`
	Description                      string             `json:"description"`
	DropID                           string             `json:"dropId"`
	DropAddress                      string             `json:"dropAddress"`
	ClaimFee                         int                `json:"claimFee"`
	Creator                          *CreatorDetails    `json:"creator"`
	AuthorizedSubdomains             []string           `json:"authorizedSubdomains,omitempty"`
	TwitterClaimCriteriaInteractions []*InteractionType `json:"twitterClaimCriteriaInteractions,omitempty"`
	TelegramGroupTitle               *string            `json:"telegramGroupTitle,omitempty"`
	TweetLink                        *string            `json:"tweetLink,omitempty"`
	ProfileLink                      *string            `json:"profileLink,omitempty"`
	CampaignName                     *string            `json:"campaignName,omitempty"`
	EditionLimit                     *int               `json:"editionLimit,omitempty"`
	TokenID                          *int               `json:"TokenID,omitempty"`
	CreatedAt                        time.Time          `json:"createdAt"`
	Deadline                         *time.Time         `json:"deadline,omitempty"`
	Holders                          []string           `json:"holders"`
}

type ItemInput struct {
	Name         *string `json:"name,omitempty"`
	Image        *string `json:"image,omitempty"`
	Description  *string `json:"description,omitempty"`
	DropID       *string `json:"dropID,omitempty"`
	UserLimit    *int    `json:"userLimit,omitempty"`
	EditionLimit *int    `json:"editionLimit,omitempty"`
	// This should typically be in cents
	ClaimFee *int `json:"claimFee,omitempty"`
}

type JWTCreationResponse struct {
	Token string `json:"token"`
}

type MintAuthorizationResponse struct {
	Amount               string `json:"amount"`
	TokenID              string `json:"tokenId"`
	Nonce                string `json:"nonce"`
	Chain                int    `json:"chain"`
	PackedData           string `json:"packedData"`
	MintingAbi           string `json:"mintingABI"`
	MintingSignature     string `json:"mintingSignature"`
	SmartContractAddress string `json:"smartContractAddress"`
}

type MobileWalletConfig struct {
	PublicKey  string `json:"publicKey"`
	PrivateKey string `json:"privateKey"`
	AaWallet   string `json:"aaWallet"`
}

type MultiChoiceInputType struct {
	Question      string   `json:"question"`
	Choices       []string `json:"choices"`
	CorrectChoice string   `json:"correctChoice"`
}

type NewEmailDomainWhitelistInput struct {
	ItemID               string   `json:"itemID"`
	Visible              bool     `json:"visible"`
	AuthorizedSubdomains []string `json:"authorizedSubdomains"`
}

type NewEmailWhitelistInput struct {
	ItemID           string   `json:"itemID"`
	AuthorizedEmails []string `json:"authorizedEmails"`
}

type NewEmptyCriteriaInput struct {
	DropID string `json:"dropID"`
}

type NewFarcasterCriteriaInput struct {
	DropID            string             `json:"dropID"`
	CastURL           *string            `json:"castUrl,omitempty"`
	ChannelID         *string            `json:"channelId,omitempty"`
	FarcasterUserName *string            `json:"farcasterUserName,omitempty"`
	Interaction       []*InteractionType `json:"interaction,omitempty"`
	CriteriaType      ClaimCriteriaType  `json:"criteriaType"`
}

type NewPatreonCriteriaInput struct {
	ItemID       string  `json:"itemID"`
	AuthID       string  `json:"authID"`
	CampaignID   *string `json:"campaignID,omitempty"`
	CampaignName *string `json:"campaignName,omitempty"`
}

type NewTelegramCriteriaInput struct {
	ItemID  string `json:"itemID"`
	GroupID string `json:"groupID"`
}

type NewTwitterCriteriaInput struct {
	ItemID        string             `json:"itemID"`
	ProfileID     *string            `json:"profileID,omitempty"`
	TweetLink     *string            `json:"tweetLink,omitempty"`
	Interaction   []*InteractionType `json:"interaction,omitempty"`
	CriteriaType  ClaimCriteriaType  `json:"criteriaType"`
	TwitterAuthID string             `json:"twitterAuthID"`
	// Format: 2006-01-02T15:04:05Z07:00 i.e YYYY-MM-DDTHH:MM:SSZ
	CutOffDate *string `json:"cutOffDate,omitempty"`
}

type NewUsernameRegisgration struct {
	AaWallet              string  `json:"aaWallet"`
	InverseUsername       string  `json:"inverseUsername"`
	ExternalWalletAddress *string `json:"externalWalletAddress,omitempty"`
}

type NewWalletAddressWhitelistInput struct {
	ItemID                    string   `json:"itemID"`
	AuthorizedWalletAddresses []string `json:"authorizedWalletAddresses"`
}

type OnboardingProgress struct {
	Creator                  *CreatorDetails `json:"creator,omitempty"`
	RegisterdInverseUsername bool            `json:"registerdInverseUsername"`
}

type OpenEndedInputType struct {
	Question string   `json:"question"`
	Answers  []string `json:"answers"`
}

type QuestionnaireAnswerInput struct {
	Answer     string `json:"answer"`
	QuestionID string `json:"questionId"`
}

type QuestionnaireCriteriaInput struct {
	ItemID           string                  `json:"itemID"`
	QuestionType     QuestionType            `json:"questionType"`
	OpenEndedInput   []*OpenEndedInputType   `json:"openEndedInput,omitempty"`
	MultiChoiceInput []*MultiChoiceInputType `json:"multiChoiceInput,omitempty"`
	ClaimCode        *bool                   `json:"claimCode,omitempty"`
}

type QuestionnaireType struct {
	//  Choices will only contain a list of potential answers when the `questionType` is `multiChoice`
	Choices      []string     `json:"choices,omitempty"`
	Question     string       `json:"question"`
	QuestionID   string       `json:"questionId"`
	QuestionType QuestionType `json:"questionType"`
	ClaimCode    *bool        `json:"claimCode,omitempty"`
}

type SignerInfo struct {
	Address   string         `json:"address"`
	Signature *string        `json:"signature,omitempty"`
	Provider  SignerProvider `json:"provider"`
}

type Socials struct {
	Twitter   *string `json:"twitter,omitempty"`
	Instagram *string `json:"instagram,omitempty"`
	Github    *string `json:"github,omitempty"`
	Warpcast  *string `json:"warpcast,omitempty"`
}

type SocialsInput struct {
	Twitter   *string `json:"twitter,omitempty"`
	Instagram *string `json:"instagram,omitempty"`
	Github    *string `json:"github,omitempty"`
	Warpcast  *string `json:"warpcast,omitempty"`
}

type StartEmailVerificationResponse struct {
	OtpRequestID string `json:"otpRequestID"`
}

type TweetDetails struct {
	ProfilePhoto  string `json:"profilePhoto"`
	ProfileName   string `json:"profileName"`
	ProfileHandle string `json:"profileHandle"`
	TweetText     string `json:"tweetText"`
}

type UserDetails struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	Username string `json:"username"`
}

type ValidationRespoonse struct {
	Valid  bool    `json:"valid"`
	PassID *string `json:"passID,omitempty"`
}

type Wallet struct {
	Balance  int    `json:"balance"`
	Currency string `json:"currency"`
}

type UserProfileType struct {
	CreatorID       *string  `json:"creatorID,omitempty"`
	Thumbnail       *string  `json:"thumbnail,omitempty"`
	Image           *string  `json:"image,omitempty"`
	InverseUsername *string  `json:"inverseUsername,omitempty"`
	Bio             *string  `json:"bio,omitempty"`
	Socials         *Socials `json:"socials,omitempty"`
	Drops           []*Drop  `json:"drops,omitempty"`
	Items           []*Item  `json:"items,omitempty"`
	ClaimedItems    []*Item  `json:"claimedItems,omitempty"`
}

type AiImageStyle string

const (
	AiImageStyleAnime            AiImageStyle = "Anime"
	AiImageStyleArtistic         AiImageStyle = "Artistic"
	AiImageStyleFuturistic       AiImageStyle = "Futuristic"
	AiImageStyleCinematic        AiImageStyle = "Cinematic"
	AiImageStyleDigitalArt       AiImageStyle = "DigitalArt"
	AiImageStyleFantasyArt       AiImageStyle = "FantasyArt"
	AiImageStyleLineArt          AiImageStyle = "LineArt"
	AiImageStyleNeonPunk         AiImageStyle = "NeonPunk"
	AiImageStyleOrigami          AiImageStyle = "Origami"
	AiImageStylePixelArt         AiImageStyle = "PixelArt"
	AiImageStyleThreeDimensional AiImageStyle = "ThreeDimensional"
)

var AllAiImageStyle = []AiImageStyle{
	AiImageStyleAnime,
	AiImageStyleArtistic,
	AiImageStyleFuturistic,
	AiImageStyleCinematic,
	AiImageStyleDigitalArt,
	AiImageStyleFantasyArt,
	AiImageStyleLineArt,
	AiImageStyleNeonPunk,
	AiImageStyleOrigami,
	AiImageStylePixelArt,
	AiImageStyleThreeDimensional,
}

func (e AiImageStyle) IsValid() bool {
	switch e {
	case AiImageStyleAnime, AiImageStyleArtistic, AiImageStyleFuturistic, AiImageStyleCinematic, AiImageStyleDigitalArt, AiImageStyleFantasyArt, AiImageStyleLineArt, AiImageStyleNeonPunk, AiImageStyleOrigami, AiImageStylePixelArt, AiImageStyleThreeDimensional:
		return true
	}
	return false
}

func (e AiImageStyle) String() string {
	return string(e)
}

func (e *AiImageStyle) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AiImageStyle(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AiImageStyle", str)
	}
	return nil
}

func (e AiImageStyle) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BlockchainNetwork string

const (
	BlockchainNetworkBase    BlockchainNetwork = "base"
	BlockchainNetworkPolygon BlockchainNetwork = "polygon"
)

var AllBlockchainNetwork = []BlockchainNetwork{
	BlockchainNetworkBase,
	BlockchainNetworkPolygon,
}

func (e BlockchainNetwork) IsValid() bool {
	switch e {
	case BlockchainNetworkBase, BlockchainNetworkPolygon:
		return true
	}
	return false
}

func (e BlockchainNetwork) String() string {
	return string(e)
}

func (e *BlockchainNetwork) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BlockchainNetwork(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BlockchainNetwork", str)
	}
	return nil
}

func (e BlockchainNetwork) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ClaimCriteriaType string

const (
	ClaimCriteriaTypeEmailWhiteList            ClaimCriteriaType = "emailWhiteList"
	ClaimCriteriaTypeEmailDomain               ClaimCriteriaType = "emailDomain"
	ClaimCriteriaTypeTwitterInteractions       ClaimCriteriaType = "twitterInteractions"
	ClaimCriteriaTypeTwitterFollowers          ClaimCriteriaType = "twitterFollowers"
	ClaimCriteriaTypeTelegram                  ClaimCriteriaType = "telegram"
	ClaimCriteriaTypePatreon                   ClaimCriteriaType = "patreon"
	ClaimCriteriaTypeDirectAnswerQuestionnaire ClaimCriteriaType = "directAnswerQuestionnaire"
	ClaimCriteriaTypeMutliChoiceQuestionnaire  ClaimCriteriaType = "mutliChoiceQuestionnaire"
	ClaimCriteriaTypeEmptyCriteria             ClaimCriteriaType = "emptyCriteria"
	ClaimCriteriaTypeWalletAddress             ClaimCriteriaType = "walletAddress"
	ClaimCriteriaTypeClaimCode                 ClaimCriteriaType = "claimCode"
	ClaimCriteriaTypeFarcasterChannel          ClaimCriteriaType = "farcasterChannel"
	ClaimCriteriaTypeFarcasterFollowing        ClaimCriteriaType = "farcasterFollowing"
	ClaimCriteriaTypeFarcasterInteractions     ClaimCriteriaType = "farcasterInteractions"
)

var AllClaimCriteriaType = []ClaimCriteriaType{
	ClaimCriteriaTypeEmailWhiteList,
	ClaimCriteriaTypeEmailDomain,
	ClaimCriteriaTypeTwitterInteractions,
	ClaimCriteriaTypeTwitterFollowers,
	ClaimCriteriaTypeTelegram,
	ClaimCriteriaTypePatreon,
	ClaimCriteriaTypeDirectAnswerQuestionnaire,
	ClaimCriteriaTypeMutliChoiceQuestionnaire,
	ClaimCriteriaTypeEmptyCriteria,
	ClaimCriteriaTypeWalletAddress,
	ClaimCriteriaTypeClaimCode,
	ClaimCriteriaTypeFarcasterChannel,
	ClaimCriteriaTypeFarcasterFollowing,
	ClaimCriteriaTypeFarcasterInteractions,
}

func (e ClaimCriteriaType) IsValid() bool {
	switch e {
	case ClaimCriteriaTypeEmailWhiteList, ClaimCriteriaTypeEmailDomain, ClaimCriteriaTypeTwitterInteractions, ClaimCriteriaTypeTwitterFollowers, ClaimCriteriaTypeTelegram, ClaimCriteriaTypePatreon, ClaimCriteriaTypeDirectAnswerQuestionnaire, ClaimCriteriaTypeMutliChoiceQuestionnaire, ClaimCriteriaTypeEmptyCriteria, ClaimCriteriaTypeWalletAddress, ClaimCriteriaTypeClaimCode, ClaimCriteriaTypeFarcasterChannel, ClaimCriteriaTypeFarcasterFollowing, ClaimCriteriaTypeFarcasterInteractions:
		return true
	}
	return false
}

func (e ClaimCriteriaType) String() string {
	return string(e)
}

func (e *ClaimCriteriaType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ClaimCriteriaType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ClaimCriteriaType", str)
	}
	return nil
}

func (e ClaimCriteriaType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ImageResolveFormaat string

const (
	ImageResolveFormaatURL    ImageResolveFormaat = "Url"
	ImageResolveFormaatBase64 ImageResolveFormaat = "Base64"
)

var AllImageResolveFormaat = []ImageResolveFormaat{
	ImageResolveFormaatURL,
	ImageResolveFormaatBase64,
}

func (e ImageResolveFormaat) IsValid() bool {
	switch e {
	case ImageResolveFormaatURL, ImageResolveFormaatBase64:
		return true
	}
	return false
}

func (e ImageResolveFormaat) String() string {
	return string(e)
}

func (e *ImageResolveFormaat) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageResolveFormaat(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageResolveFormaat", str)
	}
	return nil
}

func (e ImageResolveFormaat) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InteractionType string

const (
	InteractionTypeLikes    InteractionType = "likes"
	InteractionTypeRetweets InteractionType = "retweets"
	InteractionTypeReplies  InteractionType = "replies"
	InteractionTypeRecasts  InteractionType = "recasts"
)

var AllInteractionType = []InteractionType{
	InteractionTypeLikes,
	InteractionTypeRetweets,
	InteractionTypeReplies,
	InteractionTypeRecasts,
}

func (e InteractionType) IsValid() bool {
	switch e {
	case InteractionTypeLikes, InteractionTypeRetweets, InteractionTypeReplies, InteractionTypeRecasts:
		return true
	}
	return false
}

func (e InteractionType) String() string {
	return string(e)
}

func (e *InteractionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InteractionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InteractionType", str)
	}
	return nil
}

func (e InteractionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type QuestionType string

const (
	QuestionTypeMultiChoice  QuestionType = "multiChoice"
	QuestionTypeDirectAnswer QuestionType = "directAnswer"
)

var AllQuestionType = []QuestionType{
	QuestionTypeMultiChoice,
	QuestionTypeDirectAnswer,
}

func (e QuestionType) IsValid() bool {
	switch e {
	case QuestionTypeMultiChoice, QuestionTypeDirectAnswer:
		return true
	}
	return false
}

func (e QuestionType) String() string {
	return string(e)
}

func (e *QuestionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = QuestionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid QuestionType", str)
	}
	return nil
}

func (e QuestionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SignerProvider string

const (
	SignerProviderDynamic    SignerProvider = "dynamic"
	SignerProviderMagic      SignerProvider = "magic"
	SignerProviderWeb3Auth   SignerProvider = "web3Auth"
	SignerProviderConnectKit SignerProvider = "connectKit"
)

var AllSignerProvider = []SignerProvider{
	SignerProviderDynamic,
	SignerProviderMagic,
	SignerProviderWeb3Auth,
	SignerProviderConnectKit,
}

func (e SignerProvider) IsValid() bool {
	switch e {
	case SignerProviderDynamic, SignerProviderMagic, SignerProviderWeb3Auth, SignerProviderConnectKit:
		return true
	}
	return false
}

func (e SignerProvider) String() string {
	return string(e)
}

func (e *SignerProvider) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SignerProvider(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SignerProvider", str)
	}
	return nil
}

func (e SignerProvider) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
