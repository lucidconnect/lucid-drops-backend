// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type Collection struct {
	ID              string  `json:"ID"`
	Name            string  `json:"name"`
	Description     string  `json:"description"`
	Image           string  `json:"image"`
	Thumbnail       string  `json:"thumbnail"`
	ContractAddress *string `json:"contractAddress,omitempty"`
	Items           []*Item `json:"items"`
}

type CollectionInput struct {
	Name        *string `json:"name,omitempty"`
	Description *string `json:"description,omitempty"`
	Image       *string `json:"image,omitempty"`
	Thumbnail   *string `json:"thumbnail,omitempty"`
}

type CompleteEmailClaimInput struct {
	Otp          string `json:"otp"`
	OtpRequestID string `json:"otpRequestID"`
}

type CompleteEmailVerificationInput struct {
	Otp          string `json:"otp"`
	OtpRequestID string `json:"otpRequestID"`
}

type CompleteEmailVerificationResponse struct {
	OtpRequestID string `json:"otpRequestID"`
}

type CreatorDetails struct {
	CreatorID       string  `json:"creatorID"`
	Address         string  `json:"address"`
	InverseUsername *string `json:"inverseUsername,omitempty"`
}

type EmailClaimInput struct {
	ItemID       string `json:"itemID"`
	EmailAddress string `json:"emailAddress"`
}

type GenerateClaimSignatureInput struct {
	OtpRequestID    string `json:"otpRequestID"`
	ClaimingAddress string `json:"claimingAddress"`
}

type ImageResponse struct {
	Image  string              `json:"image"`
	Format ImageResolveFormaat `json:"format"`
}

type Item struct {
	ID                               string             `json:"ID"`
	Name                             string             `json:"name"`
	Image                            string             `json:"image"`
	Description                      string             `json:"description"`
	CollectionID                     string             `json:"collectionId"`
	ClaimCriteria                    *ClaimCriteriaType `json:"claimCriteria,omitempty"`
	Creator                          *CreatorDetails    `json:"creator"`
	AuthorizedSubdomains             []string           `json:"authorizedSubdomains,omitempty"`
	TwitterClaimCriteriaInteractions []*InteractionType `json:"twitterClaimCriteriaInteractions,omitempty"`
	TweetLink                        *string            `json:"tweetLink,omitempty"`
	ProfileLink                      *string            `json:"profileLink,omitempty"`
	CampaignName                     *string            `json:"campaignName,omitempty"`
	CreatedAt                        time.Time          `json:"createdAt"`
}

type ItemInput struct {
	Name         *string `json:"name,omitempty"`
	Image        *string `json:"image,omitempty"`
	Description  *string `json:"description,omitempty"`
	CollectionID *string `json:"collectionID,omitempty"`
}

type MintAuthorizationResponse struct {
	PackedData           string `json:"packedData"`
	MintingAbi           string `json:"mintingABI"`
	MintingSignature     string `json:"mintingSignature"`
	SmartContractAddress string `json:"smartContractAddress"`
}

type NewEmailDomainWhitelistInput struct {
	ItemID               string   `json:"itemID"`
	Visible              bool     `json:"visible"`
	AuthorizedSubdomains []string `json:"authorizedSubdomains"`
}

type NewEmailWhitelistInput struct {
	ItemID           string   `json:"itemID"`
	AuthorizedEmails []string `json:"authorizedEmails"`
}

type NewPatreonCriteriaInput struct {
	ItemID       string  `json:"itemID"`
	AuthID       string  `json:"authID"`
	CampaignID   *string `json:"campaignID,omitempty"`
	CampaignName *string `json:"campaignName,omitempty"`
}

type NewTelegramCriteriaInput struct {
	ItemID  string `json:"itemID"`
	GroupID string `json:"groupID"`
}

type NewTwitterCriteriaInput struct {
	ItemID        string             `json:"itemID"`
	ProfileID     *string            `json:"profileID,omitempty"`
	TweetLink     *string            `json:"tweetLink,omitempty"`
	Interaction   []*InteractionType `json:"interaction,omitempty"`
	CriteriaType  ClaimCriteriaType  `json:"criteriaType"`
	TwitterAuthID string             `json:"twitterAuthID"`
	// Format: 2006-01-02T15:04:05Z07:00 i.e YYYY-MM-DDTHH:MM:SSZ
	CutOffDate *string `json:"cutOffDate,omitempty"`
}

type NewUsernameRegisgration struct {
	InverseUsername string `json:"inverseUsername"`
}

type OnboardingProgress struct {
	RegisterdInverseUsername bool `json:"registerdInverseUsername"`
}

type SignerInfo struct {
	Address   string         `json:"address"`
	Signature *string        `json:"signature,omitempty"`
	Provider  SignerProvider `json:"provider"`
}

type StartEmailVerificationResponse struct {
	OtpRequestID string `json:"otpRequestID"`
}

type TweetDetails struct {
	ProfilePhoto  string `json:"profilePhoto"`
	ProfileName   string `json:"profileName"`
	ProfileHandle string `json:"profileHandle"`
	TweetText     string `json:"tweetText"`
}

type UserDetails struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	Username string `json:"username"`
}

type AiImageStyle string

const (
	AiImageStyleAnime            AiImageStyle = "Anime"
	AiImageStyleArtistic         AiImageStyle = "Artistic"
	AiImageStyleFuturistic       AiImageStyle = "Futuristic"
	AiImageStyleCinematic        AiImageStyle = "Cinematic"
	AiImageStyleDigitalArt       AiImageStyle = "DigitalArt"
	AiImageStyleFantasyArt       AiImageStyle = "FantasyArt"
	AiImageStyleLineArt          AiImageStyle = "LineArt"
	AiImageStyleNeonPunk         AiImageStyle = "NeonPunk"
	AiImageStyleOrigami          AiImageStyle = "Origami"
	AiImageStylePixelArt         AiImageStyle = "PixelArt"
	AiImageStyleThreeDimensional AiImageStyle = "ThreeDimensional"
)

var AllAiImageStyle = []AiImageStyle{
	AiImageStyleAnime,
	AiImageStyleArtistic,
	AiImageStyleFuturistic,
	AiImageStyleCinematic,
	AiImageStyleDigitalArt,
	AiImageStyleFantasyArt,
	AiImageStyleLineArt,
	AiImageStyleNeonPunk,
	AiImageStyleOrigami,
	AiImageStylePixelArt,
	AiImageStyleThreeDimensional,
}

func (e AiImageStyle) IsValid() bool {
	switch e {
	case AiImageStyleAnime, AiImageStyleArtistic, AiImageStyleFuturistic, AiImageStyleCinematic, AiImageStyleDigitalArt, AiImageStyleFantasyArt, AiImageStyleLineArt, AiImageStyleNeonPunk, AiImageStyleOrigami, AiImageStylePixelArt, AiImageStyleThreeDimensional:
		return true
	}
	return false
}

func (e AiImageStyle) String() string {
	return string(e)
}

func (e *AiImageStyle) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AiImageStyle(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AiImageStyle", str)
	}
	return nil
}

func (e AiImageStyle) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ClaimCriteriaType string

const (
	ClaimCriteriaTypeEmailWhiteList      ClaimCriteriaType = "emailWhiteList"
	ClaimCriteriaTypeEmailDomain         ClaimCriteriaType = "emailDomain"
	ClaimCriteriaTypeTwitterInteractions ClaimCriteriaType = "twitterInteractions"
	ClaimCriteriaTypeTwitterFollowers    ClaimCriteriaType = "twitterFollowers"
	ClaimCriteriaTypeTelegram            ClaimCriteriaType = "telegram"
	ClaimCriteriaTypePatreon             ClaimCriteriaType = "patreon"
)

var AllClaimCriteriaType = []ClaimCriteriaType{
	ClaimCriteriaTypeEmailWhiteList,
	ClaimCriteriaTypeEmailDomain,
	ClaimCriteriaTypeTwitterInteractions,
	ClaimCriteriaTypeTwitterFollowers,
	ClaimCriteriaTypeTelegram,
	ClaimCriteriaTypePatreon,
}

func (e ClaimCriteriaType) IsValid() bool {
	switch e {
	case ClaimCriteriaTypeEmailWhiteList, ClaimCriteriaTypeEmailDomain, ClaimCriteriaTypeTwitterInteractions, ClaimCriteriaTypeTwitterFollowers, ClaimCriteriaTypeTelegram, ClaimCriteriaTypePatreon:
		return true
	}
	return false
}

func (e ClaimCriteriaType) String() string {
	return string(e)
}

func (e *ClaimCriteriaType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ClaimCriteriaType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ClaimCriteriaType", str)
	}
	return nil
}

func (e ClaimCriteriaType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ImageResolveFormaat string

const (
	ImageResolveFormaatURL    ImageResolveFormaat = "Url"
	ImageResolveFormaatBase64 ImageResolveFormaat = "Base64"
)

var AllImageResolveFormaat = []ImageResolveFormaat{
	ImageResolveFormaatURL,
	ImageResolveFormaatBase64,
}

func (e ImageResolveFormaat) IsValid() bool {
	switch e {
	case ImageResolveFormaatURL, ImageResolveFormaatBase64:
		return true
	}
	return false
}

func (e ImageResolveFormaat) String() string {
	return string(e)
}

func (e *ImageResolveFormaat) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageResolveFormaat(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageResolveFormaat", str)
	}
	return nil
}

func (e ImageResolveFormaat) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InteractionType string

const (
	InteractionTypeLikes    InteractionType = "likes"
	InteractionTypeRetweets InteractionType = "retweets"
	InteractionTypeReplies  InteractionType = "replies"
)

var AllInteractionType = []InteractionType{
	InteractionTypeLikes,
	InteractionTypeRetweets,
	InteractionTypeReplies,
}

func (e InteractionType) IsValid() bool {
	switch e {
	case InteractionTypeLikes, InteractionTypeRetweets, InteractionTypeReplies:
		return true
	}
	return false
}

func (e InteractionType) String() string {
	return string(e)
}

func (e *InteractionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InteractionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InteractionType", str)
	}
	return nil
}

func (e InteractionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SignerProvider string

const (
	SignerProviderDynamic SignerProvider = "dynamic"
	SignerProviderMagic   SignerProvider = "magic"
)

var AllSignerProvider = []SignerProvider{
	SignerProviderDynamic,
	SignerProviderMagic,
}

func (e SignerProvider) IsValid() bool {
	switch e {
	case SignerProviderDynamic, SignerProviderMagic:
		return true
	}
	return false
}

func (e SignerProvider) String() string {
	return string(e)
}

func (e *SignerProvider) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SignerProvider(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SignerProvider", str)
	}
	return nil
}

func (e SignerProvider) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
